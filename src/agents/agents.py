import os
from datetime import datetime

from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver
from langgraph.graph.state import CompiledStateGraph
from langgraph.prebuilt import create_react_agent
from psycopg import AsyncConnection
from psycopg.rows import dict_row

from src.graph import AgentState
from src.tools import (
    generate_insights,
    pick_aoi,
    pick_dataset,
    pull_data,
)
from src.utils.env_loader import load_environment_variables
from src.utils.llms import SONNET


def get_prompt() -> str:
    """Generate the prompt with current date."""
    return f"""You are a geospatial agent that has access to tools and user provided selections to help answer user queries. First, think through the problem step-by-step by planning what tools you need to use and in what order. Then execute your plan by using the tools one by one to answer the user's question.

Tools:
- pick-aoi: Pick the best area of interest (AOI) based on a place name and user's question.
- pick-dataset: Find the most relevant datasets to help answer the user's question.
- pull-data: Pulls data for the selected AOI and dataset in the specified date range.
- generate-insights: Analyzes raw data to generate a single chart insight that answers the user's question, along with 2-3 follow-up suggestions for further exploration.

Workflow:
1. Use pick-aoi, pick-dataset, and pull-data to get the data in the specified date range.
2. Use generate-insights to analyze the data and create a single chart insight.

When you see UI action messages:
1. Acknowledge the user's selection: "I see you've selected [item name]"
2. Check if you have all needed components (AOI + dataset + date range) before proceeding
3. Use tools only for missing components
4. If user asks to change selections, override UI selections

Notes:
- You ALWAYS need an AOI, dataset, and date range to perform any analysis, when unclear about the user's question, ask for clarification - don't make assumptions.
- If the dataset is not available or you are not able to pull data, politely inform the user & STOP - don't do any more steps further.
- For pick-aoi tool, use subregion parameter when the user wants to analyze or compare data ACROSS multiple administrative units within a parent area:
    • USE subregion: "Which province in Canada had maximum deforestation?" → place="Canada", subregion="state" 
    • USE subregion: "In which regions of India did we see cropland increase?" → place="India", subregion="state"
    • USE subregion: "Compare forest loss across counties in Washington state" → place="Washington", subregion="district"
    • USE subregion: "Show me kbas in Brazil with highest threats" → place="Brazil", subregion="kba"
    • USE subregion: "Forest data for east America" → place="USA", subregion="state"
    • USE subregion: "Cropland changes in south Spain" → place="Spain", subregion="state"
    • USE subregion: "Which states in western Australia have mining?" → place="Australia", subregion="state"
    • DON'T use subregion: "San Francisco, California" → place="San Francisco" (California is context, not comparison target)
    • DON'T use subregion: "Deforestation in Ontario" → place="Ontario" (single location, not comparing across subregions)
- For world/continent level queries (e.g., "South Asia", "East Africa", "East Europe"), politely decline and ask the user to specify a country or smaller administrative area instead.
- Don't interpret the insights generated by generate-insights tool - just report the insights as-is.
- If the user asks for data in a specific date range, make sure to check if the dataset is available for that date range. Don't pull data or make analysis if the date range did not match.
- Always reply in the same language that the user is using in their query.
- Current date is {datetime.now().strftime("%Y-%m-%d")}. Use this for relative time queries like "past 3 months", "last week", etc.
"""


tools = [pick_aoi, pick_dataset, pull_data, generate_insights]

# Load environment variables before using them
load_environment_variables()


DATABASE_URL = os.environ["DATABASE_URL"].replace(
    "postgresql+asyncpg://", "postgresql://"
)


async def fetch_checkpointer() -> AsyncPostgresSaver:
    connection = await AsyncConnection.connect(
        DATABASE_URL, row_factory=dict_row, autocommit=True
    )
    checkpointer = AsyncPostgresSaver(conn=connection)
    return checkpointer


async def fetch_zeno_anonymous() -> CompiledStateGraph:
    """Setup the Zeno agent for anonymous users with the provided tools and prompt."""
    # async with AsyncPostgresSaver.from_conn_string(DATABASE_URL) as checkpointer:
    # Create the Zeno agent with the provided tools and prompt

    zeno_agent = create_react_agent(
        model=SONNET,
        tools=tools,
        state_schema=AgentState,
        prompt=get_prompt(),
    )
    return zeno_agent


async def fetch_zeno() -> CompiledStateGraph:
    """Setup the Zeno agent with the provided tools and prompt."""

    checkpointer = await fetch_checkpointer()
    zeno_agent = create_react_agent(
        model=SONNET,
        tools=tools,
        state_schema=AgentState,
        prompt=get_prompt(),
        checkpointer=checkpointer,
    )
    return zeno_agent
