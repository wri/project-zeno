# Zeno API documentation

The zeno api returns data from our zeno agents. The principle we are adopting is that the data retruned by the api are langgraph state updates.

The reasoning behind this is the following:

- We can use pydantic classes for typing the state ensuring consistency
- Minimal middle layer between the agent and the frontend
- Focus on a synced state on frontend and backend

## Chat API Endpoint

The main chat endpoint is `/api/chat` which accepts POST requests with the following schema:

```python
class ChatRequest(BaseModel):
    query: str = Field(..., description="The query")
    user_persona: Optional[str] = Field(None, description="The user persona")
    
    # UI Context - can include multiple selections
    ui_context: Optional[dict] = None  # {"aoi_selected": {...}, "dataset_selected": {...}, "daterange_selected": {...}}
    
    # Pure UI actions - no query
    ui_action_only: Optional[bool] = False
    
    # Chat info
    thread_id: Optional[str] = Field(None, description="The thread ID")
    metadata: Optional[dict] = Field(None, description="The metadata")
    session_id: Optional[str] = Field(None, description="The session ID")
    user_id: Optional[str] = Field(None, description="The user ID")
    tags: Optional[list] = Field(None, description="The tags")
```

### UI Context

The `ui_context` parameter allows the frontend to pass pre-selected data (AOI, dataset, date range) directly to the agent, enabling a hybrid approach where users can either:
1. Use natural language queries to let the agent select data
2. Use UI dropdowns to pre-select data and then ask questions
3. Mix both approaches in the same conversation

#### UI Context Schema

```python
ui_context = {
    "aoi_selected": {
        "aoi": {  # Full AOI geojson and metadata
            "geometry": {...},  # GeoJSON geometry
            "name": "Location Name",
            "gadm_id": 12345,
            # ... other AOI fields
        },
        "aoi_name": "Location Name",
        "subregion_aois": None,  # or DataFrame data
        "subregion": None,
        "subtype": "district-county"
    },
    "dataset_selected": {
        "dataset": {
            "dataset_id": 14,
            "source": "GFW",
            "data_layer": "DIST-ALERT",
            "tile_url": "https://tiles.globalforestwatch.org/...",
            "context_layer": "driver",
            "daterange": {
                "start_date": "2024-01-01",
                "end_date": "2024-12-31",
                "years": [2024],
                "period": "2024",
                "original_text": "2024"
            },
            "threshold": None
        }
    },
    "daterange_selected": {
        "start_date": "2024-01-01",
        "end_date": "2024-12-31",
        "years": None,
        "period": "2024-01-01 to 2024-12-31",
        "original_text": "2024-01-01 to 2024-12-31"
    }
}
```

### Frontend UI Components

The Streamlit frontend now includes UI selection components that work in conjunction with the chat interface:

1. **AOI Dropdown**: Pre-defined areas of interest (e.g., "Koraput" district)
2. **Dataset Dropdown**: Pre-configured datasets (e.g., "Tree Cover Loss", "DIST_ALERT")
3. **Date Range Picker**: Interactive date selection with start/end date inputs

When users make selections via these UI components, the selections are automatically passed to the chat API via the `ui_context` parameter. This enables a seamless hybrid experience where users can:
- Pre-select data via UI and then ask natural language questions
- Override UI selections with natural language ("actually, show me data for Brazil instead")
- Mix UI selections and natural language queries in the same conversation

The UI selections are acknowledged once per conversation to avoid repetitive confirmations.

## Type of updates

We have two main types of updates: AI messages and tool updates. Both are state updates, they are not different from that perspective. However, AI messages operate only on the "messages" list in the state (appending new messages), while the tool updates add to "messages" but also update other state varaibles such as aoi, chart data, dataset picked, etc.

1. The AI messages are the messages directly generated by the LLM based on questions and tool output. This includes things like thinking through a problem, too lcal lplanning, asking for clarifications, etc. These messages are always just text.
2. Tool output is the result from tool calls. These updates include the tool call itself (incl what inputs were used), and the outputs. The outputs being changes in state variables (such as dataset, or aoi).

So the complexity comes from tool updates, which we will describe in detail for each tool below.

## Streaming Response Format

The chat API returns a streaming response with `application/x-ndjson` media type. Each line contains a JSON object:

```json
{
    "node": "node_type",
    "update": "{\"serialized_state_update\"}"
}
```

- `node`: Can be "agent", "tools", or "error"
- `update`: JSON-serialized string containing the state update data

### Error Handling

Errors are sent as stream events instead of breaking the stream:

```json
{
    "node": "error",
    "update": "{\"error\": true, \"message\": \"Error description\", \"error_type\": \"ExceptionClassName\", \"type\": \"error_category\", \"fatal\": false}"
}
```

**Error Types:**
- `stream_processing_error`: Non-fatal, stream continues
- `stream_initialization_error`: Fatal, stream stops

## Agent state

The agent has all the data that the zeno needs to work. The core are the messages, which is a list of messages. The messages are the human messages (queries), the AI messages (LLM response), and tool messages (output of tools).

The state includes a lot of variables that are for internal use only and that the frontend application can safely ignore. They are currently returned by the API, but we might filter some of these on the api layers in the future.

## Tool updates

Tool updates create new messages in the message history, but more importantly directly update other state variables. These state variable udpates are the pieces of data that the frontend can use to render. Below a list of tools and their respective updates.

### Pick aoi

The first tool is picking an AOI. It updates either the `aoi`, or the `subregion_aois` fields.



The other fields are for internal use and can be ingnored on the frontend.


```python
class AgentState(TypedDict):
    # Adds one tool message string to the message history
    messages: Annotated[Sequence[BaseMessage], add_messages]
    # Structured aoi, contains geojson, name, and ID fields.
    aoi: dict
    subregion_aois: pd.DataFrame
    subregion: str
    aoi_name: str
    subtype: str
```

#### Example pick aoi output

For single aoi

```json
{
    "aoi": {
        "GID_0": "IND",
        "COUNTRY": "India", 
        "subtype": "district-county",
        "GID_1": "IND.26_1",
        "NAME_1": "Odisha",
        "VARNAME_1": null,
        "NL_NAME_1": "NA",
        "TYPE_1": null,
        "ENGTYPE_1": null,
        "CC_1": null,
        "HASC_1": null,
        "ISO_1": null,
        "GID_2": "IND.26.20_1",
        "NAME_2": "Koraput",
        "VARNAME_2": "NA",
        "NL_NAME_2": "NA",
        "TYPE_2": "District",
        "ENGTYPE_2": "District",
        "CC_2": "NA",
        "HASC_2": "IN.OR.KO",
        "GID_3": null,
        "NAME_3": null,
        "VARNAME_3": null,
        "NL_NAME_3": null,
        "TYPE_3": null,
        "ENGTYPE_3": null,
        "CC_3": null,
        "HASC_3": null,
        "GID_4": null,
        "NAME_4": null,
        "VARNAME_4": null,
        "TYPE_4": null,
        "ENGTYPE_4": null,
        "CC_4": null,
        "GID_5": null,
        "NAME_5": null,
        "TYPE_5": null,
        "ENGTYPE_5": null,
        "CC_5": null,
        "name": "Koraput, Odisha, India",
        "gadm_id": 22056,
        "geometry": {
            "type": "MultiPolygon",
            "coordinates": [...]
        }
    },
    "subregion_aois": null,
    "subregion": null,
    "aoi_name": "Koraput, Odisha, India",
    "subtype": "district-county",
    "message": "Selected AOI: Koraput, Odisha, India, type: district-county"
}
```

For multi aoi

```json
{
    "aoi": {
        "GID_0": "IND",
        "COUNTRY": "India",
        "subtype": "state-province",
        "GID_1": "IND.26_1",
        "NAME_1": "Odisha",
        "VARNAME_1": "NA",
        "NL_NAME_1": "NA",
        "TYPE_1": "State",
        "ENGTYPE_1": "State",
        "CC_1": "NA",
        "HASC_1": "IN.OR",
        "ISO_1": "IN-OR",
        "GID_2": null,
        "NAME_2": null,
        "VARNAME_2": null,
        "NL_NAME_2": null,
        "TYPE_2": null,
        "ENGTYPE_2": null,
        "CC_2": null,
        "HASC_2": null,
        "GID_3": null,
        "NAME_3": null,
        "VARNAME_3": null,
        "NL_NAME_3": null,
        "TYPE_3": null,
        "ENGTYPE_3": null,
        "CC_3": null,
        "HASC_3": null,
        "GID_4": null,
        "NAME_4": null,
        "VARNAME_4": null,
        "TYPE_4": null,
        "ENGTYPE_4": null,
        "CC_4": null,
        "GID_5": null,
        "NAME_5": null,
        "TYPE_5": null,
        "ENGTYPE_5": null,
        "CC_5": null,
        "name": "Odisha, India",
        "gadm_id": 1534,
        "geometry": {
            "type": "MultiPolygon",
            "coordinates": [...]
        }
    },
    "subregion_aois": {
        "data": [
            {
                "gfw_fid": 3261,
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [[...]]
                }
            },
            {
                "gfw_fid": 3262,
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [[...]]
                }
            },
            {
                "gfw_fid": 3263,
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [[...]]
                }
            },
            {
                "gfw_fid": 14937,
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [[...]]
                }
            },
            {
                "gfw_fid": 15089,
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [[...]]
                }
            }
        ],
        "total_rows": 5,
        "columns": 23
    },
    "subregion": "kba",
    "aoi_name": "Odisha, India",
    "subtype": "state-province",
    "message": {
        "aoi": "Selected AOI: Odisha, India, type: state-province",
        "subregions": "Subregion AOIs: 5"
    }
}
```


### Pick dataset

The second tool is responsible to pick a dataset. It sends a tool message and updates only one addtional state variable.

```python
class AgentState(TypedDict):
    # Adds one tool message string to the message history
    messages: Annotated[Sequence[BaseMessage], add_messages]
    # Structured dictionary containing the dataset info
    dataset: dict
```

#### Example output

```json
{
    "dataset": {
        "dataset_id": 14,
        "source": "GFW",
        "data_layer": "DIST-ALERT",
        "tile_url": "https://tiles.globalforestwatch.org/umd_glad_dist_alerts/latest/dynamic/{z}/{x}/{y}.png?render_type=true_color",
        "context_layer": "driver",
        "threshold": null
    },
    "message": {
        "selected_dataset": "DIST-ALERT",
        "context_layer": "driver",
        "threshold": null,
        "reasoning": "The DIST-ALERT dataset is the best match as it specifically provides near-real-time alerts of vegetation disturbance at high resolution (30m), covers the 2024 timeframe (2023-2025), and includes a \"driver\" contextual layer which would help identify the main drivers of disturbances in Koraput for Q1 2024. This dataset covers all vegetation types and is designed for monitoring ecosystem changes in near-real-time."
    }
}
```

### Pull data tool

The pull-data tool retrieves actual data from the selected dataset for the specified AOI and time range. This tool now handles date range parameters directly, making it more reliable for LLM usage.

```python
class AgentState(TypedDict):
    # Adds one tool message string to the message history
    messages: Annotated[Sequence[BaseMessage], add_messages]
    # Raw data pulled from the dataset
    raw_data: dict
    # Date range for the data pull
    start_date: str
    end_date: str
```

#### Tool Parameters

- `query`: User query providing context for the data pull
- `start_date`: Start date in YYYY-MM-DD format
- `end_date`: End date in YYYY-MM-DD format  
- `aoi_name`: Name of the area of interest
- `dataset_name`: Name of the dataset to pull from

#### Key Changes

**Date Range Handling**: Date range parameters (`start_date`, `end_date`) are now handled directly by the pull-data tool rather than being embedded within the dataset selection. This architectural change:

- Reduces complexity for the LLM when selecting datasets
- Makes date range handling more explicit and reliable
- Separates dataset selection logic from temporal filtering
- Allows for more flexible date range processing in data handlers

#### Example output

```json
{
    "raw_data": {
        "data": [...],  // Actual data from the dataset
        "metadata": {...}  // Data metadata and statistics
    },
    "start_date": "2024-01-01",
    "end_date": "2024-03-31",
    "message": "Successfully pulled data for Koraput from DIST-ALERT dataset for period 2024-01-01 to 2024-03-31"
}
```

### Generate insights tool

This tool generates insights, either tables, or differnt types of charts. The outuput chart data is compatible with `reachart.js`.

The state variables updated are the following.

```python
class AgentState(TypedDict):
    # Adds one tool message string to the message history
    messages: Annotated[Sequence[BaseMessage], add_messages]
    # generate-insights tool
    insights: list
    charts_data: list
    insight_count: int
```


#### Error handling

⚠️ This tool sometimes returns only a `message` without actual data when the chart creation fails. This breaks the expected schema of the tool output. We will address this issue soon.

This is a problem also in other tools and needs to be addressed in a better way across the agent tools.

#### Example output

Bar chart example

```json
"insights": [
    {
        "title": "Top 5 Countries with Highest Forest Loss in 2022",
        "chart_type": "bar",
        "insight": "Brazil leads significantly in forest loss with over 11.5 million hectares lost in 2022, more than double the next highest country, Indonesia (6 million hectares). The Democratic Republic of Congo ranks third with 4.77 million hectares, while Peru and Colombia have considerably lower forest loss at 1.63 and 1.24 million hectares respectively.",
        "data": [
            {"country": "Brazil", "forest_loss_ha": 11568000},
            {"country": "Indonesia", "forest_loss_ha": 6020000}, 
            {"country": "DRC", "forest_loss_ha": 4770000},
            {"country": "Peru", "forest_loss_ha": 1630000},
            {"country": "Colombia", "forest_loss_ha": 1240000}
        ],
        "x_axis": "country",
        "y_axis": "forest_loss_ha",
        "color_field": ""
    }
],
"charts_data": [
    {
        "id": "chart_1",
        "title": "Top 5 Countries with Highest Forest Loss in 2022",
        "type": "bar",
        "insight": "Brazil leads significantly in forest loss with over 11.5 million hectares lost in 2022, more than double the next highest country, Indonesia (6 million hectares). The Democratic Republic of Congo ranks third with 4.77 million hectares, while Peru and Colombia have considerably lower forest loss at 1.63 and 1.24 million hectares respectively.",
        "data": [
            {"country": "Brazil", "forest_loss_ha": 11568000},
            {"country": "Indonesia", "forest_loss_ha": 6020000},
            {"country": "DRC", "forest_loss_ha": 4770000}, 
            {"country": "Peru", "forest_loss_ha": 1630000},
            {"country": "Colombia", "forest_loss_ha": 1240000}
        ],
        "xAxis": "country",
        "yAxis": "forest_loss_ha",
        "colorField": ""
    }
],
"insight_count": 1,
"messages": [
    {
        "content": "**Insight 1: Top 5 Countries with Highest Forest Loss in 2022**\nChart Type: bar\nKey Finding: Brazil leads significantly in forest loss with over 11.5 million hectares lost in 2022, more than double the next highest country, Indonesia (6 million hectares). The Democratic Republic of Congo ranks third with 4.77 million hectares, while Peru and Colombia have considerably lower forest loss at 1.63 and 1.24 million hectares respectively.\nData Points: 5\n",
        "tool_call_id": "test-id-2"
    }
]
```

Line chart example

```json
"insights": [
    {
        "title": "Deforestation Alerts in the Amazon Region (2020-2023)",
        "chart_type": "line",
        "insight": "Deforestation alerts in the Amazon region have shown a declining trend over the past four years, decreasing from 1,450 alerts in 2021 to 980 alerts in 2023. After an initial increase of 21% from 2020 to 2021, alerts decreased by 24% in the following two years, suggesting potentially improved conservation efforts or changes in monitoring systems.",
        "data": [
            {"date": "2020-01-01", "alerts": 1200, "year": "2020"},
            {"date": "2021-01-01", "alerts": 1450, "year": "2021"},
            {"date": "2022-01-01", "alerts": 1100, "year": "2022"},
            {"date": "2023-01-01", "alerts": 980, "year": "2023"}
        ],
        "x_axis": "year",
        "y_axis": "alerts",
        "color_field": ""
    }
],
"charts_data": [
    {
        "id": "chart_1",
        "title": "Deforestation Alerts in the Amazon Region (2020-2023)",
        "type": "line",
        "insight": "Deforestation alerts in the Amazon region have shown a declining trend over the past four years, decreasing from 1,450 alerts in 2021 to 980 alerts in 2023. After an initial increase of 21% from 2020 to 2021, alerts decreased by 24% in the following two years, suggesting potentially improved conservation efforts or changes in monitoring systems.",
        "data": [
            {"date": "2020-01-01", "alerts": 1200, "year": "2020"},
            {"date": "2021-01-01", "alerts": 1450, "year": "2021"},
            {"date": "2022-01-01", "alerts": 1100, "year": "2022"},
            {"date": "2023-01-01", "alerts": 980, "year": "2023"}
        ],
        "xAxis": "year",
        "yAxis": "alerts",
        "colorField": ""
    }
],
"insight_count": 1,
"messages": [
    {
        "content": "**Insight 1: Deforestation Alerts in the Amazon Region (2020-2023)**\nChart Type: line\nKey Finding: Deforestation alerts in the Amazon region have shown a declining trend over the past four years, decreasing from 1,450 alerts in 2021 to 980 alerts in 2023. After an initial increase of 21% from 2020 to 2021, alerts decreased by 24% in the following two years, suggesting potentially improved conservation efforts or changes in monitoring systems.\nData Points: 4\n",
        "tool_call_id": "test-id-1"
    }
]
```